import re
import time
import threading
#import jmri
#import java
#import java.beans


#class TcpPeripheral_SignalHead_Listener (java.beans.PropertyChangeListener):
#	def propertyChange(self, event):
#		print "change",event.propertyName
#    		print "from", event.oldValue, "to", event.newValue
#    		print "source systemName", event.source.systemName
#    		print "source userName", event.source.userName
#		print "color", event.source.getAppearanceName()
#		print "Valid States:"
#		for state in event.source.getValidStateNames():
#			print state
#		return

#for signalhead in signals.getNamedBeanSet():
#	print signalhead.getSystemName()
#	print signalhead.getUserName()
#	signalhead.addPropertyChangeListener(TcpPeripheral_SignalHead_Listener())

def testRegEx(str):
    re_str = "(OUT_SH:([A-Z0-9\-]+)\$([0-9x]+)\$R([0-9]+)\$G([0-9]+):([r,g]?))" # sreach string to break down the turnout systemname
            
    grps = re.search (re_str, str)

    if len(grps.groups()) != 6:
        msg = str(tempMsg) + ":ERROR - regex returned inconsistent groups"
        serverTcpThread.send(msg)
        return     

    signalHeadId = grps.groups()[1]
    MCPBoardAdd = int(grps.groups()[2], 16)
    redLEDGPIO = int(grps.groups()[3])
    greenLEDGPIO = int(grps.groups()[4])
    apperance = grps.groups()[5]

    print ("Signal ID: " + signalHeadId)
    msg = "Extracted from Regex - MCPBoardAdd: " + str(MCPBoardAdd) + " red gpio: " + str(redLEDGPIO) + " green gpio: " + str(greenLEDGPIO) + " apperance: " + apperance
    print (msg)


def TcpPeripheral_getTurnoutInfo(sysName):
    servoAdd = None
    id = None
    thrownAngle = None # The angle of the servo for THROWN position
    closedAngle = None # The angle of the sero for CLOSED position
    port = 10000
    #TcpPeripheral_log.info("'TcpPeripheral' - decomposing turnout name: " + sysName)

    #
    re_str = "([A-Za-z.]+\$([0-9]+)\[([0-9]+)\]\[([0-9]+)\]:([A-Z0-9.]+):*([0-9]*))" # sreach string to break down the turnout systemname
    grps = re.search (re_str, sysName)
    
    if(len(grps.groups()) == 6):
        servoAdd = int(grps.groups()[1])
        thrownAngle = int(grps.groups()[2])
        closedAngle = int(grps.groups()[3])
        id = grps.groups()[4]
        if (grps.groups()[5] is not None):
            port = grps.groups()[5]
            id = id + ":" + port

    print ("ServoAdd: " + str(servoAdd))
    print ("thrown Angle: " + str(thrownAngle))
    print ("closed angle: " + str(closedAngle))
    print ("id: " + id)
    print ("port: " + port)

    return servoAdd, thrownAngle, closedAngle, id


def TcpPeripheral_getSignalHeadInfo(sysName):
    signalHeadCmdStr = ""
    host = ""
    port = 10000

    # Pattern to parse IH.RPI$SM1-SH1$0x24$R6$G14:PI3BMODELTRAIN:14200
    re_str = "(IH.RPI\$([A-Z0-9\-\$x]+):([A-Z0-9\.]+):?([0-9]*))" # sreach string to break down the turnout systemname
    grps = re.search (re_str, sysName)
    
    if(len(grps.groups()) == 4):
        signalHeadCmdStr = (grps.groups()[1])
        host = grps.groups()[2]
        if (grps.groups()[3] is not None):
            port = grps.groups()[3]
            host = host + ":" + port

    print ("Cmd Str: " + signalHeadCmdStr)
    print ("host: " + host)

    return signalHeadCmdStr, host


def processRecvMsg(msg):
    servoTURNOUT = {}
    
#    print ("From '" + serverTcpThread.client + "': Received [" + msg + "]")
    tempMsg = msg # for temp storage
    cmdParams = msg.split(":")
    if len(cmdParams) < 2 or (cmdParams[0].upper() != "OUT" and cmdParams[0].upper() != "IN"): # generic error
        msg = "ERROR"
        #serverTcpThread.send(msg)
        return
    inout = cmdParams[0].upper()

    if inout == "OUT":
        servoAdd = None
        thrownAngle = None # The angle of the servo for THROWN position
        closedAngle = None # The angle of the sero for CLOSED position
        active = None

        if len(cmdParams) != 3: # error for OUT command
            msg = inout + ":" + str(tempMsg) + ":ERROR - Not enough parameters for servo control"
            #serverTcpThread.send(msg)
            return
        
        re_str = "OUT:([0-9]+)\[([0-9]+)\]\[([0-9]+)\]:([0-1]+)" # sreach string to break down the turnout systemname
        grps = re.search (re_str, tempMsg)

        try:
            servoAdd = int(grps.groups()[0])
            thrownAngle = int(grps.groups()[1])
            closedAngle = int(grps.groups()[2]) 
            active = (True if int(grps.groups()[3]) == 1 else False)
        except:
            msg = inout + ":" + str(tempMsg) + ":ERROR - could not parse parameters for servo control"
            #serverTcpThread.send(msg)
            return

        if active:
            
            print ("Servo " + str(servoAdd) + " set to CLOSED")
        else:
            
            print ("Servo " + str(servoAdd) + " set to THROWN")

    return

def processRecvMsg(self, serverTcpThread, msg):
        print ("From '" + serverTcpThread.client + "': Received [" + msg + "]")
        tempMsg = msg # for temp storage
        cmdParams = msg.split(":")
        if len(cmdParams) < 2 or (cmdParams[0].startswith("OUT") and cmdParams[0].startswith("IN")): # generic error
            msg = "ERROR parsing commpand sent from JMRI " + tempMsg
            serverTcpThread.send(msg)
            return

        inout = cmdParams[0].upper()

        # Handle the turnout commands
        if inout == "OUT_TO":
            servoAdd = None
            thrownAngle = None # The angle of the servo for THROWN position
            closedAngle = None # The angle of the sero for CLOSED position
            active = None

            if len(cmdParams) != 3: # error for OUT command
                msg = inout + ":" + str(tempMsg) + ":ERROR - Not enough parameters for servo control"
                serverTcpThread.send(msg)
                return
            
            re_str = "OUT_TO:([0-9]+)\[([0-9]+)\]\[([0-9]+)\]:([0-1]+)" # sreach string to break down the turnout systemname
            grps = re.search (re_str, tempMsg)

            try:
                servoAdd = int(grps.groups()[0])
                thrownAngle = int(grps.groups()[1])
                closedAngle = int(grps.groups()[2]) 
                active = (True if int(grps.groups()[3]) == 1 else False)
            except:
                msg = inout + ":" + str(tempMsg) + ":ERROR - could not parse parameters for servo control"
                serverTcpThread.send(msg)
                return

            if servoAdd not in serverTURNOUT:
                try:
                    servoCtrlKit = ServoKit(channels=16)
                except:
                    msg = inout + ":" + str(tempMsg) + ":ERROR - could not initiate servo controller"
                    serverTcpThread.send(msg)
                    return     
                else:
                    serverTURNOUT[servoAdd] = servoCtrlKit

            if active:
                serverTURNOUT[servoAdd].servo[servoAdd].angle = closedAngle
                #print ("Servo " + str(servoAdd) + " set to CLOSED")
            else:
                serverTURNOUT[servoAdd].servo[servoAdd].angle = thrownAngle
                #print ("Servo " + str(servoAdd) + " set to THROWN")

        # Handle the command for Signalheads
        if inout == "OUT_SH":
            signalHeadId = None
            MCPBoardAdd = None
            redLEDGPIO = None
            greenLEDGPIO = None

            # Sample incoming command OUT_SH:SM1-SH1$0x24$R6$G14:r
            re_str = "(OUT_SH:([A-Z0-9\-]+)\$([0-9x]+)\$R([0-9]+)\$G([0-9]+):([r,g]?))" # sreach string to break down the turnout systemname
            
            try:
                grps = re.search (re_str, tempMsg)

                if len(grps.groups()) != 6:
                    msg = str(tempMsg) + ":ERROR - regex returned inconsistent groups"
                    serverTcpThread.send(msg)
                    return     

                signalHeadId = grps.groups()[1]
                MCPBoardAdd = int(grps.groups()[2], 16)
                redLEDGPIO = int(grps.groups()[3])
                greenLEDGPIO = int(grps.groups()[4])
                apperance = grps.groups()[5]

                msg = "Extracted from Regex - MCPBoardAdd: " + str(MCPBoardAdd) + " red gpio: " + str(redLEDGPIO) + " green gpio: " + str(greenLEDGPIO) + " apperance: " + apperance
                serverTcpThread.send(msg)
            except:
                msg = str(tempMsg) + ":ERROR - could not parse due to exception in parsing parameters for Signal Head " + signalHeadId
                serverTcpThread.send(msg)
                return

            # If the MCP board at the right address is not initialized, do it
            if MCPBoardAdd not in serverSignalHead:
                try:
                    i2c = busio.I2C(board.SCL, board.SDA)
                    mcpboard = MCP23017(i2c, address=MCPBoardAdd)
                    serverSignalHead[MCPBoardAdd] = mcpboard
                    # Initialize all the pins to output
                    for i in range(0,16):
                        pin = mcpboard.get_pin(i)
                        pin.direction = Direction.OUTPUT
                        pin.value = False
                except:
                    msg = str(tempMsg) + ":ERROR - could not initialize board for Signal Head " + signalHeadId
                    serverTcpThread.send(msg)
                    return

            # Send the command to the GPIO
            try:
                redPin = serverSignalHead[MCPBoardAdd].get_pin(redLEDGPIO)
                greenPin = serverSignalHead[MCPBoardAdd].get_pin(greenLEDGPIO)
                if apperance == "r":
                    redPin.value = True
                    greenPin.value = False
                elif apperance == "g":
                    redPin.value = False
                    greenPin.value = True
                else:
                    redPin.value = False
                    greenPin.value = False
            except:
                msg = str(tempMsg) + ":ERROR - could not set the LED GPIOs board for Signal Head " + signalHeadId
                serverTcpThread.send(msg)
                return
                    
        # Setup the different sensors for triggering 
        if inout == "IN":
            try:
                pin = int(cmdParams[1])
            except: # invalid GPIO
                pin = 9999
                msg = inout + ":" + str(pin) + ":ERROR"
                serverTcpThread.send(msg)
                return
            if len(cmdParams) != 2: # error for IN command
                msg = inout + ":" + str(pin) + ":ERROR"
                serverTcpThread.send(msg)
                return
            if pin not in gpioIN: # try to configure GPIO as input and add it to the list
                if pin in gpioOUT: # already defined for output
                    gpioOUT[pin].close() # close it and free resources
                    del gpioOUT[pin] # remove it
                try:
                    gpioAux = gpiozero.Button(pin, True) # pullup resistor
                except:
                    msg = inout + ":" + str(pin) + ":ERROR"
                    serverTcpThread.send(msg.encode())
                    return
                else:
                    gpioIN[pin] = gpioAux
                    gpioIN[pin].when_pressed = inputActivated
                    gpioIN[pin].when_released = inputDeactivated
            #print ("GPIO " + str(pin) + " registered for input")
            if gpioIN[pin].is_pressed:
                inputActivated(gpioIN[pin])
            else:
                inputDeactivated(gpioIN[pin])
        return

str2 = "OUT:0[80][50]:1"
str1 = "IT.RPi$0[93][83]:PI3BMODELTRAIN:14200"
str3 = "IH.RPI$SM1-SH1$0x24$R6$G14:PI3BMODELTRAIN:14200"
str4 = "OUT_SH:SM9-SH12$0x22$R23$G4:r"

#TcpPeripheral_getSignalHeadInfo(str3)
#TcpPeripheral_getTurnoutInfo(str1)
#processRecvMsg(str2)
#testRegEx(str4)

flashingRedSigHeadsFlag = {}
flashingRedSigHeadsThreads = {}

threadControlers = {}
blinkerThreads = {}

FLASHING_FREQ = 1
# A mrethod for blinking red and green LEDs
def flashing_LED(pin, stop):
    print (f"\tStarting Thread for {pin}")
    dutyCycle = 0.5
    onSecs = (1.0 / FLASHING_FREQ) * dutyCycle
    offSecs = (1.0 / FLASHING_FREQ) * (1 - dutyCycle)

    while(True):
        #print (f"\t\t\t {pin} High")
        time.sleep(onSecs)
        #print (f"\t\t\t {pin} Low")
        time.sleep(offSecs)
        print (f'\t\tIn thread {pin}: Value of stop: {stop()}')
        if (stop()):
            print (f"\tEnding Thread for {pin}")
            break



leds = ["l1", "l2", "l3"]

a1 = False
a2 = False
a3 = False

a = [False, False, False]

threadControlers['l1'] = False
t1 = threading.Thread(target=flashing_LED, args=['l1', lambda : threadControlers['l1']])
t1.start()
blinkerThreads['l1'] = t1

threadControlers['l2'] = False
t2 = threading.Thread(target=flashing_LED, args=['l2', lambda : threadControlers['l2']])
t2.start()
blinkerThreads['l2'] = t2

threadControlers['l3'] = False
t3 = threading.Thread(target=flashing_LED, args=['l3', lambda : threadControlers['l3']])
t3.start()
blinkerThreads['l3'] = t3

time.sleep(10)


#a[0] = True
threadControlers['l1'] = True
#t1.join()
blinkerThreads['l1'].join()
threadControlers.pop('l1')
blinkerThreads.pop('l1')

time.sleep(2)

#a[1] = True
threadControlers['l2'] = True
#t2.join()
blinkerThreads['l2'].join()
threadControlers.pop('l2')
blinkerThreads.pop('l2')

time.sleep(2)

#a[2] = True
threadControlers['l3'] = True
#t3.join()
blinkerThreads['l3'].join()

#time.sleep(2)



